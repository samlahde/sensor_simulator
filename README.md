# Sensor simulator

Sensor simulator is a fast and simple C-library for simulating sensor values. It consists only of *sensor_simulator.c* and *sensor_simulator.h* files.


## How it works

Sensor simulator at it's core is a library for getting step by step changing decimal values that over a large number of iterations follow the standard distribution. You can add error to the values, create trends that move the mean of the value distribution and change the parameters as you go.
In practice you configure the simulator with parameters suitable to you particular use case, and then call the functions repeatedly. The simulator itself does not contain any looping, it always returns just a single value. Also, to make the simulator as platform-independent as possible, the user program must also provide the pseudorandomized variables for each iteration. You can use the looping functions provided in *sim_utils* for testing.

### The *Simulator* struct

The **Simulator** struct is the object that holds the configurations for the simulation, and the persistency of values over iterations. You can directly change the parameters within the struct during simulation, or preferably use the provided initialization functions. Example of minimal initialization:
```
Simulator sim = (Simulator)malloc(sizeof(Simulator_));

init_simulator(sim, mean, standard_deviation, max_step, max_value, min_value);
```

### init_simulator()
Used for initializing the simulator with the minimum parameters. This should be called first before using any other functions.
```
void  init_simulator(Simulator  sim, double  mean, double  std_deviation, double  max_step, double  max_value, double  min_value);
```
**sim**: The simulator struct.   
**mean**: The mean of the value distribution.  
**std_deviation**: The value of the standard deviation.  
**max_step**: The maximum value by which the value changes each iteration. The actual value will be between 0 and max_step.  
**max_value & min_value**: Hard limits for the values returned.
### simulate_next_value()
This is the actual simulation function. It is called every time a simulated value is wanted. It takes into account all the configurations you have set, the previous value etc. all of which are stored in the **Simulator** struct. It returns the next value as a double.
```
double  simulate_next_value(Simulator  sim, int  random_number);
```
**sim**: The simulator struct.   
**random_number**: A random number generated by your program between *RANDOM_MINIMUM* and *RANDOM_MAXIMUM*. These are 0 and 99 by default, defined in *sensor_simulator.c*.  
 ## Optional functions
These functions are used to configure optional parameters. These should be used after *init_simulator()*.
### init_simulator_errors()
Used for adding error to the simulation. The error values are distributed randomly within the given range.
```
void  init_simulator_errors(Simulator  sim, double  error_rate, double  error_min, double  error_max);
```
**sim**: The simulator struct.   
**mean**: The mean of the value distribution.  
**error_rate**: The  probability of errors occurring in decimal. For example 0.1 = 10% error rate.  
**error_min & error_max**: The range for error values.  
### set_starting_value()
Sets the starting point of the simulation. Default is the mean.
```
void  set_starting_value(Simulator  sim, double  starting_value);
```
**sim**: The simulator struct.   
**starting_value**: The value where you want the next iteration of the simulation to start from.  
### set_steps_per_direction()
If set to other than 1, this will force the simulation go in a certain direction X steps before re-evaluating. This is useful for use cases where the values changing direction possibly every iteration is not wanted.
```
void  set_steps_per_direction(Simulator  sim, int  steps_per_direction);
```
**sim**: The simulator struct.   
**steps_per_direction**: The number of iterations the simulation will go in a direction before deciding again if the direction will be changed.  
### set_trend()
Add a trend to the simulation. This means that with each iteration, the mean of the simulator will change by *trend_speed* until the *target_mean* is reached. For example, if you want to simulate temperatures from May to June you might want to use this function to gradually change the mean of values from 12C to 19C. 
```
void  set_trend(Simulator  sim, double  target_mean, double  trend_speed);
```
**sim**: The simulator struct.   
**target_mean**: The target mean for the trend.  
**target_speed**: The value by which the mean will change each iteration.  
## Sim_utils
In *sim_utils.h* you will find functions that you can use for easy implementation. They will do the looping and random number generation for you. The use *rand()* with *srand((unsigned  int)time(0))* for seed. The values from these functions are written into a CSV file.
## Examples
There are two example files. *Sim_example1.c* is the basic  implementation, and *sim_example2.c* demoes usage of the *sim_utils*. Both write values to a CSV file.
## Python analysis
There is a simple *graph.py* script that shows the data generated by the examples in a histogram and a graph.
